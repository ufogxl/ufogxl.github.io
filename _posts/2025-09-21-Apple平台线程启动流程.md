# 从libdispatch到_start_wqthread：完整的workloop线程启动流程

## 概述

在现代Apple平台（macOS 10.13+/iOS 11.0+）上，libdispatch使用workloop机制来实现高效的并发处理。本文将深入分析从libdispatch请求线程到最终执行用户空间`_start_wqthread`入口点的完整调用链路，涵盖用户空间、内核空间以及CPU寄存器状态转换的全过程。

## 整体流程图

```
1. libdispatch请求线程
   ↓
2. 内核workqueue处理请求
   ↓
3. 内核创建线程 (thread_create_workq_waiting)
   ↓
4. 线程等待 (workq_unpark_continue)
   ↓
5. 唤醒线程 (thread_go → call_continuation)
   ↓
6. workq_setup_and_run
   ↓
7. workq_setup_thread
   ↓
8. workq_set_register_state
   ↓
9. thread_set_wq_state64 (设置CPU寄存器)
   ↓
10. 内核调度器恢复线程 (machine_switch_context)
   ↓
11. _start_wqthread (用户空间汇编入口)
   ↓
12. __pthread_wqthread → _pthread_wqthread
   ↓
13. 分发到libdispatch函数
```

## 详细流程分析

### 1. libdispatch请求线程

当workloop需要处理事件时，libdispatch会向内核发送线程请求：

```c
// src/event/event_kevent.c
static void
_dispatch_kq_fill_workloop_event(dispatch_kevent_t ke, int which,
        dispatch_wlh_t wlh, uint64_t dq_state)
{
    *ke = (dispatch_kevent_s){
        .ident  = (uintptr_t)wlh,
        .filter = EVFILT_WORKLOOP,
        .flags  = action,
        .fflags = fflags | NOTE_WL_THREAD_REQUEST,  // 线程请求标志
        .qos    = (__typeof__(ke->qos))pp,
        .udata  = (uintptr_t)wlh,
        // ...
    };
}
```

### 2. 内核workqueue处理请求

内核的workqueue子系统接收到线程请求后，检查是否需要创建新线程：

```c
// bsd/pthread/pthread_workqueue.c
bool
workq_kern_threadreq_initiate(struct proc *p, workq_threadreq_t req,
    struct turnstile *workloop_ts, thread_qos_t qos,
    workq_kern_threadreq_flags_t flags)
{
    // 检查线程池状态
    if (wq->wq_thidlecount) {
        // 有空闲线程，直接唤醒
        uth = workq_pop_idle_thread(wq, ...);
    } else {
        // 需要创建新线程
        workq_add_new_idle_thread(p, wq, workq_unpark_continue, false, NULL);
    }
}
```

### 3. 内核创建线程

```c
// bsd/pthread/pthread_workqueue.c
static kern_return_t
workq_add_new_idle_thread(
    proc_t             p,
    struct workqueue  *wq,
    thread_continue_t continuation,  // workq_unpark_continue
    bool              is_permanently_bound,
    thread_t          *new_thread)
{
    // 创建线程栈
    kret = pthread_functions->workq_create_threadstack(p, vmap, &th_stackaddr);
    
    // 创建内核线程，指定continuation函数
    kret = thread_create_workq_waiting(proc_task(p),
        continuation,  // 这里是workq_unpark_continue
        &th,
        is_permanently_bound);
    
    // 设置线程状态并加入idle队列
    struct uthread *uth = get_bsdthread_info(th);
    uth->uu_workq_stackaddr = (user_addr_t)th_stackaddr;
    wq->wq_thidlecount++;
    TAILQ_INSERT_TAIL(&wq->wq_thnewlist, uth, uu_workq_entry);
}
```

### 4. 线程等待状态

新创建的线程进入等待状态：

```c
// bsd/pthread/pthread_workqueue.c
static void
workq_park_and_unlock(proc_t p, struct workqueue *wq, struct uthread *uth, uint32_t setup_flags)
{
    // 设置等待事件
    thread_set_pending_block_hint(get_machthread(uth), kThreadWaitParkedWorkQueue);
    assert_wait(workq_parked_wait_event(uth), THREAD_INTERRUPTIBLE);
    workq_unlock(wq);
    
    // 关键：进入等待状态，指定continuation
    thread_block(workq_unpark_continue);
    __builtin_unreachable();
}
```

### 5. 线程唤醒：thread_go → call_continuation

当有工作需要处理时，内核调度器唤醒线程：

```c
// 内核调度器流程（简化）
void thread_go(thread_t thread, wait_result_t wresult)
{
    // 如果线程有continuation，直接调用continuation
    if (thread->continuation != NULL) {
        // 调用 workq_unpark_continue(parameter, wait_result)
        call_continuation(thread->continuation, parameter, wresult);
    }
}

// workq_unpark_continue被调用
static void
workq_unpark_continue(void *parameter __unused, wait_result_t wr __unused)
{
    thread_t th = current_thread();
    struct uthread *uth = get_bsdthread_info(th);
    proc_t p = current_proc();
    struct workqueue *wq = proc_get_wqptr_fast(p);
    
    // 线程从这里开始执行
    workq_lock_spin(wq);
    workq_unpark_select_threadreq_or_park_and_unlock(p, wq, uth, WQ_SETUP_NONE);
}
```

### 6. workq_setup_and_run

```c
// bsd/pthread/pthread_workqueue.c
static void
workq_setup_and_run(proc_t p, struct uthread *uth, int setup_flags)
{
    // 设置QoS、优先级等参数
    uint32_t upcall_flags = WQ_FLAG_THREAD_NEWSPI;
    if (tr_flags & WORKQ_TR_FLAG_WORKLOOP) {
        upcall_flags |= WQ_FLAG_THREAD_WORKLOOP | WQ_FLAG_THREAD_KEVENT;
    }
    uth->uu_save.uus_workq_park_data.upcall_flags = upcall_flags;
    
    // 关键调用：通过函数指针调用注册的workq_setup_thread函数
    pthread_functions->workq_setup_thread(p, th, vmap, 
        uth->uu_workq_stackaddr,
        uth->uu_workq_thport, 0, 
        setup_flags, upcall_flags);
        
    __builtin_unreachable();  // 这个函数不会返回
}
```

### 7. workq_setup_thread (内核实现)

```c
// kern/kern_support.c
void
workq_setup_thread(proc_t p, thread_t th, vm_map_t map, user_addr_t stackaddr,
        mach_port_name_t kport, int th_qos, int setup_flags, int upcall_flags)
{
    struct workq_thread_addrs th_addrs;
    user_addr_t kevent_list = 0;
    int kevent_count = 0;
    
    // 计算线程栈地址
    workq_thread_get_addrs(map, stackaddr, &th_addrs);
    
    // 如果是第一次使用，处理kevent
    if (setup_flags & WQ_SETUP_FIRST_USE) {
        workq_kevent(p, &th_addrs, ...);  
    }
    
    // 关键：设置线程寄存器状态
    workq_set_register_state(p, th, &th_addrs, kport, 
                           kevent_list, upcall_flags, kevent_count);
}
```

### 8. workq_set_register_state

```c
// kern/kern_support.c
static inline void
workq_set_register_state(proc_t p, thread_t th,
        struct workq_thread_addrs *addrs, mach_port_name_t kport,
        user_addr_t kevent_list, uint32_t upcall_flags, int kevent_count)
{
    // 获取用户空间入口函数地址
    user_addr_t wqstart_fnptr = pthread_kern->proc_get_wqthread(p);
    
    if (!wqstart_fnptr) {
        panic("workqueue thread start function pointer is NULL");
    }
    
    // 设置ARM64寄存器状态
    arm_thread_state64_t state = {
        .pc = (uint64_t)wqstart_fnptr,    // PC = _start_wqthread地址
        .x[0] = (uint64_t)addrs->self,    // 参数1: pthread_t self
        .x[1] = (uint64_t)kport,          // 参数2: mach_port_t kport  
        .x[2] = (uint64_t)addrs->stack_bottom,  // 参数3: stackaddr
        .x[3] = (uint64_t)kevent_list,    // 参数4: keventlist
        .x[4] = (uint64_t)upcall_flags,   // 参数5: flags
        .x[5] = (uint64_t)kevent_count,   // 参数6: nkevents
        .sp = (uint64_t)addrs->stack_top, // 栈指针
    };
    
    // 应用线程状态 - 这是关键步骤！
    int error = pthread_kern->thread_set_wq_state64(th, (thread_state_t)&state);
    if (error != KERN_SUCCESS) {
        panic("thread_set_wq_state failed: %d", error);
    }
}
```

### 9. thread_set_wq_state64 (设置CPU寄存器)

```c
// 在内核深处 (osfmk/arm64/thread.c 或类似位置)
int
thread_set_wq_state64(thread_t thread, thread_state_t tstate)
{
    // 将thread_state_t转换为arm_thread_state64_t
    arm_thread_state64_t *state = (arm_thread_state64_t *)tstate;
    
    // 设置线程的CPU寄存器状态
    thread->machine.user_regs = *state;  // 保存到线程的machine context
    
    // 标记线程准备运行
    thread_setrun(thread, SCHED_PREEMPT | SCHED_TAILQ);
    
    return KERN_SUCCESS;
}
```

### 10. 内核调度器恢复线程执行

当内核调度器选择这个线程运行时：

```c
// 在内核调度器中 (osfmk/kern/sched_prim.c)
static void
thread_dispatch(thread_t old_thread, thread_t new_thread)
{
    // 保存当前线程状态，加载新线程状态
    machine_switch_context(old_thread, new_thread);
    // 这会加载new_thread的CPU寄存器状态
}

// 在ARM64机器相关代码中 (osfmk/arm64/machine_routines.c)
void
machine_switch_context(thread_t old, thread_t new)
{
    // 保存old线程的寄存器
    // 加载new线程的寄存器 (包括我们之前设置的PC和参数)
    arm64_load_context(new);
}

void
arm64_load_context(thread_t thread)
{
    arm_thread_state64_t *state = &thread->machine.user_regs;
    
    // 恢复所有寄存器，包括：
    // - PC = wqstart_fnptr (_start_wqthread的地址)
    // - X0-X5 = 函数参数
    // - SP = 用户栈指针
    
    // 当这个函数返回时，CPU开始从PC指向的地址执行
    // 即从_start_wqthread开始执行！
}
```

### 11. _start_wqthread (用户空间汇编入口)

```assembly
// src/pthread_asm.s
.globl _start_wqthread
_start_wqthread:
    // 设置栈帧用于backtrace
    stp xzr, xzr, [sp, #-16]!
    
    // 调用C函数 (注意：有两个下划线)
    bl __pthread_wqthread
    
    brk #1  // 永不返回
```

### 12. __pthread_wqthread → _pthread_wqthread

```c
// src/pthread.c
void
__pthread_wqthread(pthread_t self, mach_port_t kport, void *stacklowaddr,
        void *keventlist, int flags, int nkevents)
{
    // 这实际上就是调用_pthread_wqthread
    return _pthread_wqthread(self, kport, stacklowaddr, 
                           keventlist, flags, nkevents);
}

// 实际实现
void
_pthread_wqthread(pthread_t self, mach_port_t kport, void *stacklowaddr,
        void *keventlist, int flags, int nkevents)
{
    // 线程初始化设置
    if ((flags & WQ_FLAG_THREAD_REUSE) == 0) {
        _pthread_wqthread_setup(self, kport, stacklowaddr, flags);
    }
    
    // 设置QoS等参数...
    
    // 关键：根据标志分发到libdispatch
    if (flags & WQ_FLAG_THREAD_WORKLOOP) {
        kqueue_id_t *kqidptr = (kqueue_id_t *)keventlist - 1;
        (*__libdispatch_workloopfunction)(kqidptr, &keventlist, &nkevents);
    } else if (flags & WQ_FLAG_THREAD_KEVENT) {
        (*__libdispatch_keventfunction)(&keventlist, &nkevents);
    } else {
        (*__libdispatch_workerfunction)(workq_function2_arg);
    }
}
```

### 13. 分发到libdispatch函数

最终回到libdispatch执行实际工作：

```c
// src/queue.c
static void
_dispatch_workloop_worker_thread(uint64_t *workloop_id,
        dispatch_kevent_t *events, int *nevents)
{
    if (!workloop_id || !dispatch_assume(*workloop_id != 0)) {
        return _dispatch_kevent_worker_thread(events, nevents);
    }
    
    dispatch_wlh_t wlh = (dispatch_wlh_t)*workloop_id;
    _dispatch_adopt_wlh(wlh);
    _dispatch_wlh_worker_thread(wlh, *events, nevents);
    _dispatch_preserve_wlh_storage_reference(wlh);
}
```

## 关键转换点分析

### 内核→用户空间的转换

整个流程中最关键的转换发生在步骤9-10之间：

1. **步骤9**：`thread_set_wq_state64`将CPU寄存器状态保存到线程的machine context中
2. **步骤10**：当内核调度器选择该线程运行时，`machine_switch_context`恢复这些寄存器状态

**这不是函数调用**，而是**CPU状态的直接设置和恢复**！

### pthread_functions函数指针表

内核与pthread库通过函数指针表进行交互：

```c
// kern/kern_init.c - 内核模块初始化时注册
const struct pthread_functions_s pthread_internal_functions = {
    .workq_setup_thread = workq_setup_thread,  // 指向内核的实现
    .thread_set_wq_state64 = thread_set_wq_state64,
    // ...其他函数...
};

kern_return_t pthread_start(__unused kmod_info_t * ki, __unused void *d)
{
    // 向内核注册pthread函数表
    pthread_kext_register((pthread_functions_t)&pthread_internal_functions, &pthread_kern);
    return KERN_SUCCESS;
}
```

### wqstart_fnptr的来源

`_start_wqthread`的地址是在进程启动时，pthread库通过`bsdthread_register`系统调用注册到内核的：

```c
// 用户空间pthread库调用
bsdthread_register(_pthread_start,         // 普通线程入口
                  _start_wqthread,         // workqueue线程入口！  
                  stack_size, ...);
```

## 总结

从libdispatch请求线程到`_start_wqthread`的执行，经历了复杂的跨层调用：

1. **用户空间请求**：libdispatch → 内核workqueue
2. **内核创建线程**：workqueue → thread_create → continuation机制
3. **线程唤醒**：thread_go → continuation执行
4. **状态设置**：workq_setup → 设置CPU寄存器
5. **上下文切换**：内核调度器恢复CPU状态
6. **用户空间执行**：从_start_wqthread开始执行
7. **回到libdispatch**：通过函数指针调用工作函数

整个过程展现了Apple平台精巧的线程管理机制，通过内核级的workqueue、continuation机制和CPU状态管理，实现了高效的用户空间线程调度。

这种设计的优势在于：
- **零拷贝线程切换**：避免用户态-内核态频繁切换
- **精确QoS传递**：优先级信息直接传递给内核调度器  
- **高效资源管理**：内核统一管理线程池
- **死锁检测**：内核级别的所有权跟踪

workloop作为Apple在macOS 10.13+引入的高性能并发机制，相比传统kevent提供了更好的性能和更精确的资源管理，是现代Apple平台并发编程的核心基础设施。